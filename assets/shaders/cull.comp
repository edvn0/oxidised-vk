#version 450
layout(local_size_x = 256) in;

struct Transform { 
    mat4 m; 
};

layout(set = 0, binding = 0, std430) readonly buffer Transforms {
    Transform trs[];
};

layout(set = 0, binding = 1, std430) writeonly buffer Visibility {
    uint vis[];
};

layout(set = 0, binding = 2, std140) uniform Frustum {
    vec4 planes[6];
};

// Extract scale from model matrix to estimate bounding sphere radius
float extract_max_scale(mat4 m) {
    vec3 scale_x = vec3(m[0][0], m[1][0], m[2][0]);
    vec3 scale_y = vec3(m[0][1], m[1][1], m[2][1]);
    vec3 scale_z = vec3(m[0][2], m[1][2], m[2][2]);
    
    float sx = length(scale_x);
    float sy = length(scale_y);
    float sz = length(scale_z);
    
    return max(max(sx, sy), sz);
}

// Conservative radius estimation for torus knot
// Adjust BASE_RADIUS for your mesh (measure in Blender/viewer)
const float BASE_RADIUS = 3.5; // Distance from origin to furthest vertex

bool sphere_frustum_test(vec3 center, float radius, vec4 frustum_planes[6]) {
    // Test against all 6 planes
    // For infinite projection, far plane (index 5) might be degenerate
    // We detect this by checking if the normal is near-zero
    
    for (int i = 0; i < 6; ++i) {
        vec3 normal = frustum_planes[i].xyz;
        float plane_d = frustum_planes[i].w;
        
        // Skip degenerate planes (infinite far plane)
        float normal_len_sq = dot(normal, normal);
        if (normal_len_sq < 0.0001) {
            continue;
        }
        
        float dist = dot(normal, center) + plane_d;
        if (dist < -radius) {
            return false; // Outside this plane
        }
    }
    return true;
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    
    // Bounds check
    if (id >= trs.length()) {
        // Still write 0 for out-of-bounds
        if (id < vis.length()) {
            vis[id] = 0u;
        }
        return;
    }
    
    mat4 model = trs[id].m;
    vec3 world_pos = model[3].xyz;
    
    // Estimate bounding sphere radius from scale
    float scale = extract_max_scale(model);
    float radius = scale * BASE_RADIUS;
    
    bool visible = sphere_frustum_test(world_pos, radius, planes);
    
    vis[id] = visible ? 1u : 0u;
}